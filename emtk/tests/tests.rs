use alloy_signer_local::PrivateKeySigner;
use std::env;
use std::fs::remove_file;
use std::path::PathBuf;
use std::process::Command;

const PASSWORD: &str = "meow";

#[test]
fn generate_keystores() {
    // Reference addresses generated by providing the mnemonic to
    // https://elxor.github.io/eth-key-utils/#/accounts-from-mnemonic
    assert_keystore_address(0, "0x224990f829227A1b504901F32f377723B4Be15f7");
    assert_keystore_address(1, "0x6B8bAA6fD6bb500146C91cc443970Fe729043d69");
    assert_keystore_address(2, "0x9A8863b9e613da3D8D17B1066A9516858a817ea0");
}

fn emtk_cmd() -> Command {
    let bin = env!("CARGO_BIN_EXE_emtk");
    let path = bin
        .parse::<PathBuf>()
        .expect("should parse CARGO_TARGET_DIR");

    Command::new(path)
}

/// Generate a keystore using the given `index`. Then read it back and ensure
/// the generated keystore uses the given `address`.
fn assert_keystore_address(index: u32, address: &str) {
    let dir = env::var("CARGO_MANIFEST_DIR").unwrap();

    let output = emtk_cmd()
        .arg("--index")
        .arg(index.to_string())
        .arg("--password")
        .arg(PASSWORD)
        .arg("--output-dir")
        .arg(&dir)
        .arg("--mnemonic")
        .arg(
            "wear crucial left gorilla zebra child similar salmon seed \
            survey artwork invite digital giggle enjoy",
        )
        .output()
        .expect("Failed to execute emtk");

    // Check if the command executed successfully
    assert!(
        output.status.success(),
        "Command failed with status: {:?}\nStderr: {}",
        output.status,
        String::from_utf8_lossy(&output.stderr)
    );
    let stdout = String::from_utf8_lossy(&output.stdout);
    let path = format!("{dir}/{stdout}");
    dbg!(&path);

    let keystore = PrivateKeySigner::decrypt_keystore(&path, PASSWORD)
        .expect("Failed to load generated keystore");

    assert_eq!(keystore.address().to_string(), address);

    remove_file(&path).expect("Unable to remove keystore file");
}
